
    00000000004011a0 <check_flag>:
      ...

      4011bc:	e8 cf fe ff ff       	call   401090 <open@plt>
      4011c1:	89 45 fc             	mov    DWORD PTR [rbp-0x4],eax
      4011c4:	83 7d fc ff          	cmp    DWORD PTR [rbp-0x4],0xffffffff
      4011c8:	75 1e                	jne    4011e8 <check_flag+0x48>
      4011ca:	48 8d 05 3c 0e 00 00 	lea    rax,[rip+0xe3c]        # 40200d <_IO_stdin_used+0xd>
      4011d1:	48 89 c7             	mov    rdi,rax
      4011d4:	b8 00 00 00 00       	mov    eax,0x0
      4011d9:	e8 62 fe ff ff       	call   401040 <printf@plt>

      ...

The `check_flag` function opens and reads the flag.txt file. 
Before printing it checks if a local variable's value is -1 
We do not have control over that local variable


    00000000004011eb <vuln>:
      4011eb:	55                   	push   rbp
      4011ec:	48 89 e5             	mov    rbp,rsp
      4011ef:	48 83 ec 10          	sub    rsp,0x10
      4011f3:	48 8d 45 f8          	lea    rax,[rbp-0x8]
      4011f7:	ba 2c 01 00 00       	mov    edx,0x12c
      4011fc:	48 89 c6             	mov    rsi,rax
      4011ff:	bf 00 00 00 00       	mov    edi,0x0
      401204:	e8 47 fe ff ff       	call   401050 <read@plt>
      401209:	90                   	nop
      40120a:	c9                   	leave
      40120b:	c3                   	ret

The vulnerabilty lies in the vuln function. It reads an input of size 300 from the user and never validates it 
which means we can jump to any function from vuln function and not just the main function from which it is called

Now we cannot simply jump to an address after the `cmp` instruction in win because then the file will never be opened

There is another function called `gift` which is never called. 

    0000000000401196 <gift>:
      401196:	55                   	push   rbp
      401197:	48 89 e5             	mov    rbp,rsp
      40119a:	0f 05                	syscall
      40119c:	c3                   	ret
      40119d:	90                   	nop
      40119e:	5d                   	pop    rbp
      40119f:	c3                   	ret




We cannot execute any shellcode on the stack as the stack is not executable

Output of `cat /proc/[procID]/maps`

    7fff0bf10000-7fff0bf32000 rw-p 00000000 00:00 0                          [stack]

The stack does not have x permission

The security features 

    Arch:       amd64-64-little
    RELRO:      Partial RELRO
    Stack:      No canary found
    NX:         NX enabled
    PIE:        No PIE (0x400000)
    Stripped:   No

I googled a bit and found out that there is something called `Return oriented programming (ROP)` which could come in handy


A ROP attack does not inject malicious instructions rather it uses instructions sequences already present in memory, these are called gadgets.
A typical data execution prevention implementation cannot defend against this attack because the attacker did not directly execute the instruction. 
The instructions already present in memory are combined by manipulating the return address.

I think we can use the `gift()` function as a gadget to call `open` and then use the `readv` syscall from `vuln()` and then use `printf()` from `check_flag()`


After the read syscall in `vuln` function the `RAX` register is loaded with the size of the input. Then this RAX register will be used to direct the syscall in gift function.
The offset from the input buffer to the return address is `16` and the size of the return address is `3` which means we can call `readv` syscall


